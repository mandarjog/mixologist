// Code generated by protoc-gen-go.
// source: google/api/servicecontrol/v1/quota_properties.proto
// DO NOT EDIT!

package servicecontrol

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// Supported quota enforcement modes.
type QuotaProperties_QuotaMode int32

const (
	// Decreases available quota by the cost specified for the operation.
	// If cost is higher than available quota, operation fails and returns
	// error.
	QuotaProperties_ACQUIRE QuotaProperties_QuotaMode = 0
	// Decreases available quota by the cost specified for the operation.
	// If cost is higher than available quota, operation does not fail and
	// available quota goes down to zero but it returns error.
	QuotaProperties_ACQUIRE_BEST_EFFORT QuotaProperties_QuotaMode = 1
	// Does not change any available quota. Only checks if there is enough
	// quota.
	// No lock is placed on the checked tokens neither.
	QuotaProperties_CHECK QuotaProperties_QuotaMode = 2
	// Increases available quota by the operation cost specified for the
	// operation.
	QuotaProperties_RELEASE QuotaProperties_QuotaMode = 3
)

var QuotaProperties_QuotaMode_name = map[int32]string{
	0: "ACQUIRE",
	1: "ACQUIRE_BEST_EFFORT",
	2: "CHECK",
	3: "RELEASE",
}
var QuotaProperties_QuotaMode_value = map[string]int32{
	"ACQUIRE":             0,
	"ACQUIRE_BEST_EFFORT": 1,
	"CHECK":               2,
	"RELEASE":             3,
}

func (x QuotaProperties_QuotaMode) String() string {
	return proto.EnumName(QuotaProperties_QuotaMode_name, int32(x))
}
func (QuotaProperties_QuotaMode) EnumDescriptor() ([]byte, []int) { return fileDescriptor5, []int{0, 0} }

// Represents the properties needed for quota operations.
//
// Use the metric_value_sets field in Operation message to provide cost
// override with metric_name in <service_name>/quota/<quota_group_name>/cost
// format. Overrides for unmatched quota groups will be ignored.
// Costs are expected to be >= 0. Cost 0 will cause no quota check,
// but still traffic restrictions will be enforced.
type QuotaProperties struct {
	// Quota mode for this operation.
	QuotaMode QuotaProperties_QuotaMode `protobuf:"varint,1,opt,name=quota_mode,json=quotaMode,enum=google.api.servicecontrol.v1.QuotaProperties_QuotaMode" json:"quota_mode,omitempty"`
	// LimitType IDs that should be used for checking quota. Key in this map
	// should be a valid LimitType string, and the value is the ID to be used. For
	// ex., an entry <USER, 123> will cause all user quota limits to use 123 as
	// the user ID. See google/api/quota.proto for the definition of LimitType.
	// CLIENT_PROJECT: Not supported.
	// USER: Value of this entry will be used for enforcing user-level quota
	//       limits. If none specified, caller IP passed in the
	//       servicecontrol.googleapis.com/caller_ip label will be used instead.
	//       If the server cannot resolve a value for this LimitType, an error
	//       will be thrown. No validation will be performed on this ID.
	LimitByIds map[string]string `protobuf:"bytes,2,rep,name=limit_by_ids,json=limitByIds" json:"limit_by_ids,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *QuotaProperties) Reset()                    { *m = QuotaProperties{} }
func (m *QuotaProperties) String() string            { return proto.CompactTextString(m) }
func (*QuotaProperties) ProtoMessage()               {}
func (*QuotaProperties) Descriptor() ([]byte, []int) { return fileDescriptor5, []int{0} }

func (m *QuotaProperties) GetLimitByIds() map[string]string {
	if m != nil {
		return m.LimitByIds
	}
	return nil
}

func init() {
	proto.RegisterType((*QuotaProperties)(nil), "google.api.servicecontrol.v1.QuotaProperties")
	proto.RegisterEnum("google.api.servicecontrol.v1.QuotaProperties_QuotaMode", QuotaProperties_QuotaMode_name, QuotaProperties_QuotaMode_value)
}

func init() {
	proto.RegisterFile("google/api/servicecontrol/v1/quota_properties.proto", fileDescriptor5)
}

var fileDescriptor5 = []byte{
	// 304 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0x94, 0x91, 0x41, 0x6b, 0xc2, 0x30,
	0x14, 0xc7, 0x97, 0x8a, 0x1b, 0x7d, 0x8e, 0x59, 0x32, 0x61, 0x32, 0x76, 0x10, 0x4f, 0x9e, 0x52,
	0xd4, 0xc3, 0xc6, 0xc0, 0x83, 0x95, 0xc8, 0x64, 0x8e, 0x69, 0x74, 0xbb, 0x86, 0x6a, 0x83, 0x84,
	0x55, 0x53, 0xd3, 0x58, 0xe8, 0xf7, 0xdc, 0x87, 0xd9, 0x71, 0xd4, 0x6e, 0x85, 0xf5, 0x20, 0xec,
	0xf6, 0xfe, 0x2f, 0xfc, 0x7e, 0xe4, 0xcf, 0x83, 0xfe, 0x46, 0xa9, 0x4d, 0x28, 0x5c, 0x3f, 0x92,
	0x6e, 0x2c, 0x74, 0x22, 0xd7, 0x62, 0xad, 0x76, 0x46, 0xab, 0xd0, 0x4d, 0xba, 0xee, 0xfe, 0xa0,
	0x8c, 0xcf, 0x23, 0xad, 0x22, 0xa1, 0x8d, 0x14, 0x31, 0x89, 0xb4, 0x32, 0x0a, 0xdf, 0xe5, 0x10,
	0xf1, 0x23, 0x49, 0xfe, 0x42, 0x24, 0xe9, 0xb6, 0x3f, 0x2d, 0xa8, 0xcf, 0x33, 0x70, 0x56, 0x70,
	0xf8, 0x1d, 0x20, 0x77, 0x6d, 0x55, 0x20, 0x9a, 0xa8, 0x85, 0x3a, 0x57, 0xbd, 0x7b, 0x72, 0x4a,
	0x43, 0x4a, 0x8a, 0x3c, 0xbf, 0xa8, 0x40, 0x30, 0x7b, 0xff, 0x3b, 0x62, 0x0e, 0x97, 0xa1, 0xdc,
	0x4a, 0xc3, 0x57, 0x29, 0x97, 0x41, 0xdc, 0xb4, 0x5a, 0x95, 0x4e, 0xad, 0x37, 0xf8, 0x9f, 0x79,
	0x9a, 0x19, 0xbc, 0x74, 0x12, 0xc4, 0x74, 0x67, 0x74, 0xca, 0x20, 0x2c, 0x16, 0xb7, 0x03, 0xa8,
	0x97, 0x9e, 0xb1, 0x03, 0x95, 0x0f, 0x91, 0x1e, 0x4b, 0xd8, 0x2c, 0x1b, 0x71, 0x03, 0xaa, 0x89,
	0x1f, 0x1e, 0x44, 0xd3, 0x3a, 0xee, 0xf2, 0xf0, 0x68, 0x3d, 0xa0, 0xf6, 0x04, 0xec, 0xe2, 0xdf,
	0xb8, 0x06, 0x17, 0xc3, 0xd1, 0xfc, 0x6d, 0xc2, 0xa8, 0x73, 0x86, 0x6f, 0xe0, 0xfa, 0x27, 0x70,
	0x8f, 0x2e, 0x96, 0x9c, 0x8e, 0xc7, 0xaf, 0x6c, 0xe9, 0x20, 0x6c, 0x43, 0x75, 0xf4, 0x44, 0x47,
	0xcf, 0x8e, 0x95, 0x01, 0x8c, 0x4e, 0xe9, 0x70, 0x41, 0x9d, 0x8a, 0x37, 0x80, 0xd6, 0x5a, 0x6d,
	0x4f, 0x36, 0xf3, 0x1a, 0xa5, 0x6a, 0xb3, 0xec, 0x5c, 0x33, 0xf4, 0x85, 0xd0, 0xea, 0xfc, 0x78,
	0xba, 0xfe, 0x77, 0x00, 0x00, 0x00, 0xff, 0xff, 0x5e, 0xe0, 0x31, 0xc9, 0xf1, 0x01, 0x00, 0x00,
}
