// Package stackdriver provides direct access to Cloud Logging for
// structured logs export.
//
// To use, access is needed to client creds for oauth2-based
// authentication. At this time, creds are expected to be
// supplied via a kubernetes secret mounted to the mixologist
// pod in location "/etc/stackdriver/svc-acct-creds.json".
//
// At this time, those creds should be generated by creating
// a service account in the producer project for the service
// being called (and/or have perms on that producer project).
//
// TODO: have this adapter configued by producer project, so
// that the logs for an instance ALWAYS go to a single project
// per adapter instance.
package stackdriver

import (
	"cloud.google.com/go/logging/apiv2"
	"errors"
	"fmt"
	"github.com/golang/glog"
	structpb "github.com/golang/protobuf/ptypes/struct"
	timestamppb "github.com/golang/protobuf/ptypes/timestamp"
	"golang.org/x/net/context"
	"google.golang.org/api/option"
	resourcepb "google.golang.org/genproto/googleapis/api/monitoredres"
	loggingtypepb "google.golang.org/genproto/googleapis/logging/type"
	loggingpb "google.golang.org/genproto/googleapis/logging/v2"
	"reflect"
	"github.com/cloudendpoints/mixologist/mixologist"
	"github.com/cloudendpoints/mixologist/mixologist/rc/logsAdapter"
)

const (

	// Name uniquely identifies this adapter..
	// TODO(dougreid): do we need a better name here?
	Name = "logging.googleapis.com/v2beta1/"

	// CloudPlatformScope is the oauth scope for all of google cloud.
	CloudPlatformScope = "https://www.googleapis.com/auth/cloud-platform"

	// LoggingAdminScope is the oauth scope for all of admin actions for logs.
	LoggingAdminScope = "https://www.googleapis.com/auth/logging.admin"

	// LoggingWriteScope is the oauth scope for all of writing logs.
	LoggingWriteScope = "https://www.googleapis.com/auth/logging.write"

	// LogProducerName uniquely identifies the source of the logs in
	// cloud logging.
	LogProducerName = "mixologist.io/mixologist"

	// managed resource labels

	// ProjectID is a label for the managed resource type 'api'.
	ProjectID = "project_id"
	// Location is a label for the managed resource type 'api'.
	Location = "location"
	// Service is a label for the managed resource type 'api'.
	Service = "service"
	// Method is A label for the managed resource type 'api'.
	Method = "method"
	// Version is a label for the managed resource type 'api'.
	Version = "version"

	// creds location (const for now -- could move into supplier)
	// credsFile = "/etc/stackdriver/creds.json"
	svcAcctFile = "/etc/stackdriver/svc-acct-creds.json"
)

func init() { logsAdapter.RegisterLogsSink(Name, new(builder)) }

type (
	logger struct {
		c loggingClient
	}

	builder struct{}

	// LoggingClient is an interface used to wrap the imported logger to allow
	// easy testing of this package.
	loggingClient interface {
		WriteLogEntries(ctx context.Context, req *loggingpb.WriteLogEntriesRequest) (*loggingpb.WriteLogEntriesResponse, error)
	}
)

func (b *builder) Build(c mixologist.Config) mixologist.Logger {
	// at some point, we probably want to plumb contexts through
	ctx := context.Background()
	client, err := logging.NewClient(ctx, option.WithServiceAccountFile(svcAcctFile), option.WithScopes(CloudPlatformScope, LoggingAdminScope, LoggingWriteScope))
	if err != nil {
		glog.Errorf("could not build stackdriver logger: %v", err)
		return nil
	}
	return &logger{c: client}
}

func (l *logger) Name() string { return Name }
func (l *logger) Flush()       {}
func (l *logger) Log(le mixologist.LogEntry) error {

	glog.Infof("logging to stackdriver: %v", le)

	// TODO(): pass thru contexts for logging?
	ctx := context.Background()

	// a aggregating version of this could queue logs for
	// export via WriteLogEntriesRequest

	req := &loggingpb.WriteLogEntriesRequest{
		// for now, don't specify default log names or resources or labels
		Entries:        []*loggingpb.LogEntry{convert(le)},
		PartialSuccess: true,
	}

	// resp is an empty proto
	_, err := l.c.WriteLogEntries(ctx, req)
	if err != nil {
		glog.Errorf("could not log to stackdriver: %v", err)
		return err
	}

	return nil
}

// stackdriver log names MUST be of the form:
//  - "projects/<project-id>/logs/<log-id>"
func logName(pid, log string) string {
	return fmt.Sprintf("projects/%s/logs/%s", pid, log)
}

func producerProject(l mixologist.LogEntry) (string, error) {
	// check if CloudProject label is set and return if it is
	if p, ok := l.Labels[mixologist.CloudProject]; ok {
		return p, nil
	}

	// check if "producer_project_id" is set and return if it is
	if p, ok := l.StructPayload["producer_project_id"]; ok {
		return p.(string), nil
	}

	return "", errors.New("no known producer project for service")
}

func convert(l mixologist.LogEntry) *loggingpb.LogEntry {

	ppid, err := producerProject(l)
	if err != nil {
		// TODO(dougreid): provide better error handling
		return nil
	}

	l.Resource.Labels[mixologist.CloudProject] = ppid

	le := &loggingpb.LogEntry{
		LogName:   logName(ppid, l.Name),
		Resource:  monitoredResource(l),
		Timestamp: timestamp(l),
		Severity:  severity(l),
		InsertId:  l.ID,
		// HttpRequest: httpRequest(l),
		Labels:    labels(l),
		Operation: operation(l),
	}

	// no common exported interface for payloads
	if l.TextPayload != "" {
		le.Payload = &loggingpb.LogEntry_TextPayload{TextPayload: l.TextPayload}
	}
	// TODO(dougreid): figure out proto payload options here
	// if l.ProtoPayload != "" {
	// 	le.Payload = &loggingpb.LogEntry_ProtoPayload{ProtoPayload: l.ProtoPayload}
	// }
	if len(l.StructPayload) != 0 {
		le.Payload = &loggingpb.LogEntry_JsonPayload{
			JsonPayload: structPayload(l.StructPayload),
		}
	}

	glog.Infof("log entry emitted to stackdriver: %v", le)

	return le
}

// stackdriver monitored resources require the following labels:
//  - project_id
//  - service
//  - version
//  - method
//  - location
func resourceLabels(le mixologist.LogEntry) map[string]string {
	l := map[string]string{
		ProjectID: "UNKNOWN",
		Service:   "UNKNOWN",
		Version:   "UNKNOWN",
		Method:    "UNKNOWN",
		Location:  "UNKNOWN",
	}

	glog.Infof("monitored resource labels, input: %v", le.Labels)
	if v, ok := le.Resource.Labels[mixologist.CloudProject]; ok {
		l[ProjectID] = v
	}
	if v, ok := le.Resource.Labels[mixologist.CloudService]; ok {
		glog.Infof("service found: %s", v)
		l[Service] = v
	}
	if v, ok := le.Resource.Labels[mixologist.APIVersion]; ok {
		l[Version] = v
	}
	if v, ok := le.Resource.Labels[mixologist.APIMethod]; ok {
		l[Method] = v
	}
	if v, ok := le.Resource.Labels[mixologist.CloudLocation]; ok {
		l[Location] = v
	}
	glog.Infof("monitored resource labels, output: %v", l)
	return l
}

func monitoredResource(l mixologist.LogEntry) *resourcepb.MonitoredResource {
	return &resourcepb.MonitoredResource{
		Type:   l.Resource.Type,
		Labels: resourceLabels(l),
	}
}

func timestamp(l mixologist.LogEntry) *timestamppb.Timestamp {
	return &timestamppb.Timestamp{
		Seconds: l.Timestamp.Unix(),
		Nanos:   int32(l.Timestamp.Nanosecond()),
	}
}

func severity(l mixologist.LogEntry) loggingtypepb.LogSeverity {
	switch l.Severity {
	case "DEBUG":
		return loggingtypepb.LogSeverity_DEBUG
	case "INFO":
		return loggingtypepb.LogSeverity_INFO
	case "NOTICE":
		return loggingtypepb.LogSeverity_NOTICE
	case "WARNING":
		return loggingtypepb.LogSeverity_WARNING
	case "ERROR":
		return loggingtypepb.LogSeverity_ERROR
	case "CRITICAL":
		return loggingtypepb.LogSeverity_CRITICAL
	case "ALERT":
		return loggingtypepb.LogSeverity_ALERT
	case "EMERGENCY":
		return loggingtypepb.LogSeverity_EMERGENCY
	default:
		return loggingtypepb.LogSeverity_DEFAULT
	}
}

func httpRequest(l mixologist.LogEntry) *loggingtypepb.HttpRequest {
	return nil
}

func labels(l mixologist.LogEntry) map[string]string {
	return l.Labels
}

func operation(l mixologist.LogEntry) *loggingpb.LogEntryOperation {
	// LogEntryOperation {need operation id, producer: "github.com/cloudendpoints/mixologist"}
	return &loggingpb.LogEntryOperation{
		Id:       l.OperationID,
		Producer: LogProducerName,
	}
}

func structValue(in interface{}) *structpb.Value {
	switch reflect.TypeOf(in).Kind() {
	case reflect.String:
		return &structpb.Value{Kind: &structpb.Value_StringValue{StringValue: in.(string)}}
	// TODO(dougreid): what about:
	// reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64, reflect.Float32,
	// reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64 ?
	case reflect.Float64:
		return &structpb.Value{Kind: &structpb.Value_NumberValue{NumberValue: in.(float64)}}
	case reflect.Bool:
		return &structpb.Value{Kind: &structpb.Value_BoolValue{BoolValue: in.(bool)}}
	case reflect.Array, reflect.Slice:
		t := []*structpb.Value{}
		for _, v := range in.([]interface{}) {
			t = append(t, structValue(v))
		}
		return &structpb.Value{Kind: &structpb.Value_ListValue{ListValue: &structpb.ListValue{Values: t}}}
	case reflect.Struct:
		m := map[string]*structpb.Value{}
		for k, v := range in.(map[string]interface{}) {
			m[k] = structValue(v)
		}
		return &structpb.Value{Kind: &structpb.Value_StructValue{StructValue: &structpb.Struct{Fields: m}}}
	default:
		// TODO(dougreid): is this what we want here?
		return &structpb.Value{Kind: &structpb.Value_NullValue{NullValue: structpb.NullValue_NULL_VALUE}}
	}
}

func structPayload(m map[string]interface{}) *structpb.Struct {
	tmp := map[string]*structpb.Value{}
	for k, v := range m {
		tmp[k] = structValue(v)
	}
	return &structpb.Struct{Fields: tmp}
}
